plugins {
    kotlin("multiplatform") version Deps.JetBrains.Kotlin.VERSION
    id("com.github.johnrengelman.shadow") version Deps.Plugins.Shadow.VERSION
    application
}

group = "com.hoffi"
version = "1.0.0"
val artifactName by extra { project.name.toLowerCase() }
val theMainClass by extra { "com.hoffi.dsl.App" }

repositories {
    mavenCentral()
}

application {
    mainClass.set(theMainClass + "Kt")
    println("main Application: ${mainClass.get()}")
}
//tasks.getByName<JavaExec>("run") {
//    systemProperty("java.awt.headless", "true") // disable app icon on macOS
//    classpath(tasks.getByName<Jar>("jvmJar")) // so that the JS artifacts generated by `jvmJar` can be found and served
//    //classpath(project.getConfigurations().getByName("jvmRuntimeClasspath").files)
//}

//val run by tasks.getting(JavaExec::class) {
//    group = group
//    main = theMainClass + "Kt"
//    kotlin {
//        val main = targets["jvm"].compilations["main"]
//        dependsOn(main.compileAllTaskName)
//        classpath(
//            { main.output.allOutputs.files },
//            { configurations["jvmRuntimeClasspath"] }
//        )
//    }
//    systemProperty("java.awt.headless", "true") // disable app icon on macOS
//}

kotlin {
    jvm() {
        //// create an executable java fat jar
        //val jvmJar by tasks.getting(org.gradle.jvm.tasks.Jar::class) {
        //    doFirst {
        //        // configurations.forEach { println(it.name) }
        //        manifest {
        //            attributes["Main-Class"] = theMainClass + "Kt"
        //        }
        //        from(configurations.getByName("jvmRuntimeClasspath").map { if (it.isDirectory) it else zipTree(it) })
        //    }
        //}
    }
    sourceSets {
        val commonMain by getting {
            dependencies {
                //implementation("io.github.microutils:kotlin-logging:2.0.6")
                implementation("org.jetbrains.kotlinx:kotlinx-datetime:${Deps.Misc.DATETIME.VERSION}")
                implementation("com.github.ajalt.clikt:clikt:${Deps.Misc.CLIKT.VERSION}")
            }
        }
        val commonTest by getting {
            dependencies {
                implementation(kotlin("test-common"))
                implementation(kotlin("test-annotations-common"))
            }
        }
        val jvmMain by getting { // named("jvmMain") {
            dependencies {

            }
        }
        val jvmTest by getting { // named("jvmTest") {
            dependencies {

            }
        }
    }
}

java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

tasks {
    withType<Jar> {
        archiveBaseName.set(artifactName)
    }
    withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
        kotlinOptions {
            jvmTarget = java.targetCompatibility.majorVersion
            //Will retain parameter names for Java reflection
            javaParameters = true
            //freeCompilerArgs = freeCompilerArgs + listOf(
            //    "--Xjavac-arguments=-Xlint:-deprecation"
            //)
        }
    }

    withType<Test> {
        // classpath += developmentOnly

        useJUnitPlatform {
            //includeEngines("junit-jupiter", "spek2")
            // includeTags "fast"
            // excludeTags "app", "integration", "messaging", "slow", "trivial"
        }
        failFast = false
        ignoreFailures = false
        // reports.html.isEnabled = true

        testLogging {
            showStandardStreams = true
            exceptionFormat = org.gradle.api.tasks.testing.logging.TestExceptionFormat.FULL
            events = setOf(
                org.gradle.api.tasks.testing.logging.TestLogEvent.PASSED,
                org.gradle.api.tasks.testing.logging.TestLogEvent.FAILED,
                org.gradle.api.tasks.testing.logging.TestLogEvent.SKIPPED
            ) //, STARTED //, standardOut, standardError)
        }

        addTestListener(object : TestListener {
            override fun beforeTest(descriptor: TestDescriptor?) {
                logger.lifecycle("Running $descriptor")
            }

            override fun beforeSuite(p0: TestDescriptor?) = Unit
            override fun afterTest(desc: TestDescriptor, result: TestResult) = Unit
            override fun afterSuite(desc: TestDescriptor, result: TestResult) {
                if (desc.parent == null) { // will match the outermost suite
                    println("\nTotal Test Results:")
                    println("===================")
                    val failsDefault = "${result.failedTestCount} failures"
                    val fails =
                        if (result.failedTestCount > 0) colorString(ConsoleColor.RED, failsDefault) else failsDefault
                    val outcome = if (result.resultType.name == "FAILURE") colorString(
                        ConsoleColor.RED,
                        result.resultType.name
                    ) else colorString(ConsoleColor.GREEN, result.resultType.name)
                    println("Test Results: ${outcome} (total: ${result.testCount} tests, ${result.successfulTestCount} successes, $fails, ${result.skippedTestCount} skipped)\n")
                }
            }
        })

        // listen to standard out and standard error of the test JVM(s)
        // onOutput { descriptor, event -> logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event.message ) }
    }

    // shadowJar {
    //     //exclude("META-INF/ECLIPSE_.RSA", "META-INF/ECLIPSE_.SF")
    //     mergeServiceFiles()
    //     archiveBaseName.set(artifactName)
    // }
    val shadowCreate by creating(com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar::class) {
        manifest {
            attributes["Main-Class"] = theMainClass + "Kt"
        }
        mergeServiceFiles()

        archiveClassifier.set("fat")
        from(kotlin.jvm().compilations.getByName("main").output)
        configurations =
            mutableListOf(kotlin.jvm().compilations.getByName("main").compileDependencyFiles as Configuration)
    }
    val build by existing {
        dependsOn(shadowCreate)
    }
}

// ################################################################################################
// #####    pure informational stuff on stdout    #################################################
// ################################################################################################
tasks.register("printClasspath") {
    group = "misc"
    description = "print classpath"
    doLast {
        project.getConfigurations().filter { it.isCanBeResolved }.forEach {
            println(it.name)
        }
        println()
        val targetConfigurationNames = listOf(
            "metadataCommonMainCompileClasspath",
            "commonMainApiDependenciesMetadata",
            "commonMainImplementationDependenciesMetadata",
            "jvmCompileClasspath",
            "kotlinCompilerClasspath",
            "jvmRuntimeClasspath",
        )
        targetConfigurationNames.forEach {
            println("$it:")
            println("=".repeat("$it:".length))
            project.getConfigurations()
                .getByName(it).files
                // filters only existing and non-empty dirs
                .filter { file -> (file.isDirectory() && file.listFiles().isNotEmpty()) || file.isFile() }
                .forEach { println(it) }
        }
    }
}

//tasks.register("versionsPrint") {
//    group = "misc"
//    description = "extract spring boot versions from dependency jars"
//    doLast {
//        val foreground = ConsoleColor.YELLOW
//        val background = ConsoleColor.DEFAULT
//        val shadowJar by tasks.getting(com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar::class)
//        printlnColor(foreground, "  fat/uber jar: ${shadowJar.archiveFileName.get()}", background)
//        printlnColor(foreground, "Gradle version: " + project.getGradle().getGradleVersion(), background)
//        printColor(foreground, "Kotlin version: " + kotlin.coreLibrariesVersion); if (kotlin.coreLibrariesVersion != Deps.JetBrains.Kotlin.VERSION) printColor(ConsoleColor.RED, " ( != ${Deps.JetBrains.Kotlin.VERSION} )")
//        println()
//        printlnColor(foreground,"javac  version: " + org.gradle.internal.jvm.Jvm.current(), background) // + " with compiler args: " + options.compilerArgs, backgroundColor = ConsoleColor.DARK_GRAY)
//        printlnColor(foreground, "       srcComp: " + java.sourceCompatibility, background)
//        printlnColor(foreground, "       tgtComp: " + java.targetCompatibility, background)
//        printlnColor(foreground, "versions of core dependencies:", background)
//        val regex =
//            Regex(pattern = "^(spring-cloud-starter|spring-boot-starter|micronaut-core|kotlin-stdlib-jdk[0-9-]+|foundation-desktop)-[0-9].*$")
//        if (subprojects.size > 0) {
//            configurations.compileClasspath.get().map { it.nameWithoutExtension }.filter { it.matches(regex) }
//                .forEach { printlnColor(foreground, String.format("%-25s: %s", project.name, it), background) }
//        } else {
//            configurations.compileClasspath.get().map { it.nameWithoutExtension }.filter { it.matches(regex) }
//                .forEach { printlnColor(foreground, "  $it", background) }
//        }
//    }
//}
